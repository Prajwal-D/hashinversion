# -*- coding: utf-8 -*-
"""RainbowTable.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NvX5WPhkl6dAJq8SAUVZtNyEMPg6DBn0
"""

"""Imports
"""

import random
import hashlib as h
import time
import numpy as np

# my_set = set()
# random.seed("120320251")
#create numpy custom datatype of 4 bytes
hash_data_type = np.dtype('S4')
num_bytes = 4
random.seed("testSeed")

"""Apply function - hash and then XOR."""

def apply_function(c, previous):
  current = h.sha1(previous).digest()[:num_bytes]
  current = bytes(x^y for x, y in zip(c, current))[:num_bytes]
  return current

def apply_function_reverse(previous, num_times):
  current = previous
  for i in range(0, num_times):
    current = bytes(x^y for x, y in zip(i.to_bytes(num_bytes, "big"), current))[:num_bytes]
    current = h.sha1(current).digest()[:num_bytes]
    print("Performed XOR with ", i, " then hashed")
  return current

"""Generate random password of a given size"""

def get_random_password(size):
  global num_bytes
  num_bytes = size // 8
  new = random.getrandbits(size)
  password = new.to_bytes(num_bytes, "big")

  hashed_value = apply_function(b'\x00\x00\x00\x00', password)
  return (password, hashed_value)

"""Generate random start point method"""

def generate_start_points(num_chains, input_size):

  global num_bytes
  start_points = [0 for i in range(num_chains)]
  start_points = np.array(start_points, dtype=hash_data_type)

  for i in range(0, num_chains):
    new = random.getrandbits(input_size)
    num_bytes = input_size//8
    start_points[i] = new.to_bytes(num_bytes, "big")

  print(start_points)

  return start_points

"""Generate end point method"""

def generate_end_points(start_points, chain_length):

  num_chains = len(start_points)

  end_points = [0 for i in range(num_chains)]
  end_points = np.array(end_points, dtype=hash_data_type)

  for i in range(0, num_chains):
    current = start_points[i]
    for j in range(0, chain_length):
      current = apply_function(j.to_bytes(num_bytes, "big"), current)
      print(current)
    end_points[i] = current
    print("")

  print(end_points)
  return end_points

"""Find chain entry method"""

def find_chain_entry(chain_number, stop_point, start_points):
  current = start_points[chain_number]
  for i in range(stop_point):
    c = i.to_bytes(num_bytes, "big")
    current =  apply_function(c, current)
  return current

"""Inverse hash method"""

def search_chains(tp, y, start_points, end_points, chain_length):

  true_password = tp
  hash_of_password = y
  num_chains = len(start_points)
  collision_count = 0
  max = (chain_length - 1).to_bytes(num_bytes, "big")

  for i in range(0, chain_length):

    print("Hash of password", hash_of_password)
    hash_of_password = bytes(x^y for x, y in zip(max, hash_of_password))[:num_bytes]
    print("XOR performed with", (chain_length-1))
    print("Hash of password to be searched for", hash_of_password)

    for j in range(0, num_chains):
      current_end_point = end_points[j]

      if (current_end_point == hash_of_password):
        password_guess = find_chain_entry(chain_number=j, stop_point=chain_length-i-1, start_points=start_points)

        print("Match found!!")

        if(password_guess == true_password):
          print("Inverse of:", y, "is", password_guess)
          print("")
          return (True, collision_count)

        else:
          print("Collision!")
          collision_count = collision_count + 1

      # c = chain_length-i-1
      hash_of_password = apply_function_reverse(y, i+1)

  return (False, collision_count)

"""Generate a given number of password and hash pairs and return them"""

def generate_passwords(num, num_bits):
  my_passwords = list()
  for i in range(num):
    my_passwords.append(get_random_password(num_bits))
  my_passwords[0] = (b'\xb3G', b'\x0e\xe0')
  my_passwords[1] = (b'\x8bb', b'O\xef')
  print(my_passwords)
  return my_passwords

def hellman_table(no_chains, chain_len, no_iterations, hash_size):

  collision_count = 0
  inverse_success = 0

  #time Hellman table creation
  start = time.time()
  my_start_points = generate_start_points(no_chains, hash_size)
  my_end_points = generate_end_points(my_start_points, chain_len)
  end = time.time()
  table_time = end-start

  my_passwords = generate_passwords(no_iterations, hash_size)

  #time search algorithm
  start = time.time()
  for i in range(no_iterations):
    x = search_chains(my_passwords[i][0], my_passwords[i][1], my_start_points, my_end_points, chain_len)
    collision_count += x[1]
    if(x[0]):
      inverse_success += 1

  end = time.time()
  search_time = end-start

  accuracy = inverse_success / no_iterations
  return (accuracy, collision_count, table_time, search_time)

"""Master code"""

"""Format of output is as follows: no_tables,no_chains,chain_length,no_iterations,_hash_size,accuracy(percentage),no_collisions, table generation time,
search algorithm time, total execution time, coverage"""

def writeResults(p):
  # f = open("HellmanNumPy.txt", "a")
  for i in range(0, 9):
    # f.write(str(p[i]) + "--")
    print(str(p[i]) + "--")
  # f.write('\n')
  # f.close()

def masterMethod(p):
  # global my_set
  # my_set = set()
  parameters = p
  start = time.time()
  my_results = hellman_table(no_chains=parameters[0], chain_len=parameters[1], no_iterations=parameters[2], hash_size=parameters[3])
  end = time.time()

  #accuracy
  parameters.append(my_results[0]*100)

  #collision_count
  parameters.append(my_results[1])

  #table generation time
  parameters.append(my_results[2])

  #search algorithm time
  parameters.append(my_results[3])

  #total execution time
  total_time = end-start
  parameters.append(total_time)

  #total unique values in table
  # coverage = len(my_set)
  # parameters.append(coverage)

  #number of searched values within the set of unique values in table
  # parameters.append(my_results[4])

  #write file
  writeResults(parameters)


parameters = [1, 5, 2, 16]
masterMethod(parameters)

print(h.sha1(b'\xb3G').digest()[:2])

print(h.sha1(b'\x8bb').digest()[:2])

print(h.sha1(b'\x0e\xe0').digest()[:2])
one = 1
print(apply_function(one.to_bytes(2, "big"), b'\x0e\xe0'))

two = 2
print(apply_function(two.to_bytes(2, "big"), b'\x8bb'))

# x = b'\xb3Gx\xe7'
# for i in range(0, 10):
#   print(x)
#   x = apply_function(i.to_bytes(4, "big"), x)
# print(x)